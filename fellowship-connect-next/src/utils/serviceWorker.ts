// Service worker configuration for PWA capabilities
import { precacheAndRoute } from 'workbox-precaching';
import type { PrecacheEntry } from 'workbox-precaching';

// TypeScript declarations for service worker
declare global {
  // Extend the window interface to include the service worker global scope
  interface ServiceWorkerGlobalScopeEventMap {
    install: ExtendableEvent;
    fetch: FetchEvent;
  }

  // Define ServiceWorkerGlobalScope properties and methods
  interface ServiceWorkerGlobalScope {
    __WB_MANIFEST: Array<string | PrecacheEntry>;
    addEventListener<K extends keyof ServiceWorkerGlobalScopeEventMap>(
      type: K,
      listener: (this: ServiceWorkerGlobalScope, ev: ServiceWorkerGlobalScopeEventMap[K]) => void,
      options?: boolean | AddEventListenerOptions
    ): void;
  }
  
  // Define event interfaces if they're not available
  interface ExtendableEvent extends Event {
    waitUntil<T>(promise: Promise<T>): void;
  }
  
  interface FetchEvent extends Event {
    request: Request;
    respondWith(response: Response | Promise<Response>): void;
  }
}

// TypeScript declaration for the service worker global scope
declare const self: ServiceWorkerGlobalScope;


// Precache assets generated by Vite
// This will automatically include all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache first for static assets

// Network first for API calls

// Offline fallback page
const offlineFallbackPage = '/offline.html';

// Install event - cache offline page
self.addEventListener('install', (event: ExtendableEvent) => {
  event.waitUntil(
    caches.open('offline-cache').then((cache) => {
      return cache.add(offlineFallbackPage);
    })
  );
});

// Fetch event - handle offline requests
self.addEventListener('fetch', (event: FetchEvent) => {
  // Skip cross-origin requests
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .catch(() => {
          return caches.open('offline-cache')
            .then((cache) => {
              return cache.match(offlineFallbackPage)
                .then((response) => {
                  return response || new Response('Offline content not available');
                });
            });
        })
    );
  }
});